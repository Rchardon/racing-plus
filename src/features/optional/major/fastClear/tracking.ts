// This file deals with tracking whether NPCs are alive or dead

import g from "../../../../globals";

export function checkAdd(npc: EntityNPC): void {
  const isBoss = npc.IsBoss();

  // Don't do anything if we are already tracking this NPC
  const ptrHash = GetPtrHash(npc);
  if (g.run.fastClear.aliveEnemies.get(ptrHash) !== undefined) {
    return;
  }

  // We don't care if this is a non-battle NPC
  if (!npc.CanShutDoors) {
    return;
  }

  // We don't care if the NPC is already dead
  // (this is needed because we can enter this function from the NPCUpdate callback)
  if (npc.IsDead()) {
    return;
  }

  // Rag Man Raglings (246.1) do not actually die; they turn into patches on the ground
  // So, they will get past the above check
  if (
    npc.Type === EntityType.ENTITY_RAGLING &&
    npc.Variant === 1 &&
    npc.State === NpcState.STATE_UNIQUE_DEATH
    // (they go to STATE_UNIQUE_DEATH when they are patches on the ground)
  ) {
    return;
  }

  // We don't care if this is a specific child NPC attached to some other NPC
  if (isAttachedNPC(npc)) {
    return;
  }

  checkFlushOldRoom();
  add(ptrHash, isBoss);
}

/**
 * Checks for NPCs that have "CanShutDoors" set to true naturally by the game,
 * but shouldn't actually keep the doors closed.
 */
function isAttachedNPC(npc: EntityNPC) {
  return (
    // My Shadow (23.0.1)
    // These are the black worms generated by My Shadow; they are similar to charmed enemies,
    // but do not actually have the "charmed" flag set,
    // so we don't want to add them to the "aliveEnemies" table
    (npc.Type === EntityType.ENTITY_CHARGER &&
      npc.Variant === 0 &&
      npc.SubType === 1) ||
    // Chubber Projectile (39.22)
    // (needed because Fistuloids spawn them on death)
    (npc.Type === EntityType.ENTITY_VIS && npc.Variant === 22) ||
    // Death Scythe (66.10)
    (npc.Type === EntityType.ENTITY_DEATH && npc.Variant === 10) ||
    // Peep Eye (68.10)
    (npc.Type === EntityType.ENTITY_PEEP && npc.Variant === 10) ||
    // Bloat Eye (68.11)
    (npc.Type === EntityType.ENTITY_PEEP && npc.Variant === 11) ||
    // Begotten Chain (251.10)
    (npc.Type === EntityType.ENTITY_BEGOTTEN && npc.Variant === 10) ||
    // Mama Gurdy Left Hand (266.1)
    (npc.Type === EntityType.ENTITY_MAMA_GURDY && npc.Variant === 1) ||
    // Mama Gurdy Right Hand (266.2)
    (npc.Type === EntityType.ENTITY_MAMA_GURDY && npc.Variant === 2) ||
    // Small Hole (411.1)
    (npc.Type === EntityType.ENTITY_BIG_HORN && npc.Variant === 1) ||
    // Big Hole (411.2)
    (npc.Type === EntityType.ENTITY_BIG_HORN && npc.Variant === 2)
  );
}

function checkFlushOldRoom() {
  const roomFrameCount = g.r.GetFrameCount();

  // If we are entering a new room, flush all of the stuff in the old room
  // (we can't use the PostNewRoom callback to handle this since that callback fires after this one)
  // (roomFrameCount will be at -1 during the initialization phase)
  if (roomFrameCount === -1 && !g.run.fastClear.roomInitializing) {
    g.run.fastClear.aliveEnemies = new LuaTable();
    g.run.fastClear.aliveEnemiesCount = 0;
    g.run.fastClear.aliveBossesCount = 0;
    g.run.fastClear.roomInitializing = true; // (this will get set back to false in the PostNewRoom callback)
    g.run.fastClear.delayFrame = 0;
  }
}

function add(ptrHash: int, isBoss: boolean) {
  // Keep track of the enemies in the room that are alive
  g.run.fastClear.aliveEnemies.set(ptrHash, isBoss);
  g.run.fastClear.aliveEnemiesCount += 1;
  if (isBoss) {
    g.run.fastClear.aliveBossesCount += 1;
  }
}

/** As soon as an NPC dies, we want to remove it from the "aliveEnemies" map. */
export function checkRemove(npc: EntityNPC, parentFunction: string): void {
  // We only care about entities that are in the "aliveEnemies" table
  const ptrHash = GetPtrHash(npc);
  const isBoss = g.run.fastClear.aliveEnemies.get(ptrHash);
  if (isBoss === null) {
    return;
  }

  // The PostEntityKill callback will be triggered when a Dark Red champion changes to a flesh pile
  // This does not count as a real death (and the NPC should not be removed),
  // so we need to handle this
  // We cannot check for "npc.GetSprite().GetFilename() === "gfx/024.000_Globin.anm2"",
  // because that will not work for champion Gapers & Globins
  // We cannot check for "npc.GetSprite().IsPlaying("ReGenChamp")",
  // because that will only be updated on the next frame
  if (
    npc.GetChampionColorIdx() === ChampionColor.DARK_RED &&
    parentFunction === "PostEntityKill"
  ) {
    // We do not want to open the doors yet until the flesh pile is actually removed in the
    // PostEntityRemove callback
    return;
  }

  remove(ptrHash, isBoss);
}

function remove(ptrHash: int, isBoss: boolean) {
  const gameFrameCount = g.g.GetFrameCount();

  // Keep track of the enemies in the room that are alive
  g.run.fastClear.aliveEnemies.set(ptrHash, null);
  g.run.fastClear.aliveEnemiesCount -= 1;
  if (isBoss) {
    g.run.fastClear.aliveBossesCount -= 1;
  }

  // If this was the last NPC in the room that died,
  // we want to delay a frame before opening the doors to give time for splitting enemies to spawn
  // their children
  g.run.fastClear.delayFrame = gameFrameCount + 1;

  // We check on every frame to see if the "aliveEnemiesCount" variable is set to 0 the PostUpdate
  // callback
}
